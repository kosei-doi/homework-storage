# 配列とリストの違い - 超わかりやすく解説

## 📋 基本の違い

### 配列（Array）
- **要素数が固定**：最初に決めたサイズは変更できない
- **メモリが連続**：メモリ上に連続して並んでいる
- **高速アクセス**：任意の位置に直接アクセス可能（O(1)）

### リスト（List / アレイリスト）
- **要素数が可変**：後から増やしたり減らしたりできる
- **自動拡張**：容量が足りなくなったら自動的に拡張される
- **挿入・削除が可能**：途中に要素を入れたり、削除したりできる

---

## 🎯 具体的な違い

### 1. **サイズの固定 vs 可変**

#### 配列の場合
```c
// 配列：サイズは最初に決める必要がある
int arr[10];  // 10個までしか入らない
arr[0] = 1;
arr[1] = 2;
// ... 10個まで
// arr[10] = 11;  // これはできない！エラー！
```

**問題点**：
- 最初に「いくつ必要か」を正確に知る必要がある
- 足りなくなったら新しい配列を作って全部コピーする必要がある

#### リストの場合
```c
// リスト：好きなだけ追加できる
List* l = ListCreate();
ListAdd(l, 1.0);
ListAdd(l, 2.0);
ListAdd(l, 3.0);
// ... 何個でも追加可能！
ListAdd(l, 100.0);  // OK!
```

**利点**：
- 最初にサイズを決める必要がない
- 自動的に容量が拡張される

---

### 2. **挿入・削除の可否**

#### 配列の場合
```c
int arr[10] = {1, 2, 3, 4, 5, 0, 0, 0, 0, 0};

// 途中に挿入したい場合：手動で全部ずらす必要がある
// 例：2の後ろに99を入れたい

// 1. 後ろの要素を全部ずらす
for (int i = 4; i >= 2; i--) {
    arr[i + 1] = arr[i];
}
// 2. 空いた場所に入れる
arr[2] = 99;
// → {1, 2, 99, 3, 4, 5, 0, 0, 0, 0}

// 削除も同じ：手動で全部前に詰める必要がある
```

**大変な点**：
- 自分で要素をずらすコードを書く必要がある
- 間違えやすい
- 時間がかかる

#### リストの場合
```c
List* l = ListCreate();
ListAdd(l, 1.0);
ListAdd(l, 2.0);
ListAdd(l, 3.0);
ListAdd(l, 4.0);
ListAdd(l, 5.0);

// 途中に挿入：1行でできる！
ListInsert(l, 2, 99.0);  // 2番目の位置に99を挿入
// → {1, 2, 99, 3, 4, 5}

// 削除も簡単！
ListRemove(l, 1);  // 1番目を削除
// → {1, 99, 3, 4, 5}
```

**便利な点**：
- 関数を呼ぶだけで済む
- 内部で自動的に要素をずらしてくれる

---

### 3. **メモリの使用量**

#### 配列の場合
```c
int arr[1000];  // 1000個分のメモリを常に確保
// でも実際には10個しか使わない場合もある
// → 990個分のメモリが無駄になる
```

**問題点**：
- 使わない分のメモリも確保してしまう
- または、足りなくなって使えない

#### リストの場合
```c
List* l = ListCreate();  // 最初は4個分だけ確保
ListAdd(l, 1.0);
ListAdd(l, 2.0);
// ... 必要に応じて自動拡張
// 必要な分だけメモリを使う
```

**利点**：
- 必要に応じて拡張される
- 無駄が少ない（ただし、少し余分に確保することもある）

---

### 4. **アクセス速度**

#### 配列の場合
```c
int arr[100] = {...};
int x = arr[50];  // 直接アクセス！超高速！
arr[50] = 999;    // 直接代入！超高速！
```

**特徴**：
- 任意の位置に**直接アクセス**可能
- メモリアドレスを計算するだけ
- 時間計算量：**O(1)**（一定時間）

#### リストの場合
```c
List* l = ListCreate();
// ... データを追加 ...

double x = ListGetItem(l, 50);  // 内部では配列なので高速
ListSetItem(l, 50, 999.0);      // 内部では配列なので高速
```

**特徴**：
- アレイリストの場合、内部は配列なので同じく高速
- 時間計算量：**O(1)**（一定時間）
- ただし、関数呼び出しのオーバーヘッドはある

---

## 📊 比較表

| 特徴 | 配列 | アレイリスト（List.cで実装） |
|------|------|---------------------------|
| **サイズ** | 固定 | 可変（自動拡張） |
| **要素の追加** | ❌ できない | ✅ 可能（末尾） |
| **要素の挿入** | ❌ 手動でずらす必要 | ✅ 可能（任意の位置） |
| **要素の削除** | ❌ 手動で詰める必要 | ✅ 可能（任意の位置） |
| **アクセス速度** | ⚡⚡⚡ 超高速 | ⚡⚡⚡ 高速 |
| **メモリ効率** | △ 固定サイズ | ○ 必要な分だけ |
| **コードの書きやすさ** | △ 自分で管理 | ✅ 関数で簡単 |

---

## 🔍 List.cでの実装の仕組み

### アレイリストの中身
```c
typedef struct {
    double* Data;    // 内部では実は配列を使っている！
    int Size;        // 確保した容量
    int Count;       // 実際に入っているデータ数
} List;
```

**重要なポイント**：
- リストは**内部で配列を使っている**
- 配列の不便な点を関数で隠して、便利に使えるようにしている

### 自動拡張の仕組み
```c
void ListInsert(List* l, int index, double value) {
    if (l->Count < l->Size) {
        // 空きがある：そのまま使う
    } else {
        // 空きがない：2倍のサイズに拡張
        l->Size *= 2;
        l->Data = ALLOCN(double, l->Size);  // 新しい配列を作る
        // 古いデータをコピー
        free(old);  // 古い配列を解放
    }
}
```

**イメージ**：
```
最初：Size=4, Count=0
Data: [空] [空] [空] [空]

3個追加後：Size=4, Count=3
Data: [1] [2] [3] [空]

もう1個追加しようとすると：
- Count(3) < Size(4) なので空きがある
- そのまま追加

さらに追加すると：
- Count(4) >= Size(4) なので空きがない
- Sizeを2倍に（Size=8）
- 新しい配列を作ってデータをコピー
- 古い配列を削除
```

---

## 🎯 いつどちらを使うべきか？

### 配列を使う場合 ✅
- **要素数が最初から決まっている**
  - 例：1週間の気温データ（7個固定）
  - 例：月の日数（12個固定）
- **高速なアクセスが必要**
- **メモリを最小限に抑えたい**
- **シンプルな処理**

```c
// 例：1週間の気温
double temperature[7] = {15.5, 16.2, 17.1, 18.0, 17.5, 16.8, 15.9};
```

### リストを使う場合 ✅
- **要素数が予測できない**
  - 例：ユーザーが入力するデータ
  - 例：ファイルから読み込む行数が不明
- **途中で追加・削除が頻繁に発生する**
  - 例：ToDoリスト
  - 例：動的に変わるデータ
- **コードを簡単に書きたい**

```c
// 例：ユーザーが入力した数値を保存
List* numbers = ListCreate();
while (ユーザーが入力する間) {
    double value = 入力を受け取る();
    ListAdd(numbers, value);  // 何個でも追加できる
}
```

---

## 💡 まとめ

### 配列
- **固定サイズ**のデータ構造
- **高速**だが**柔軟性が低い**
- 要素数が分かっている時に使う

### リスト（アレイリスト）
- **可変サイズ**のデータ構造
- **柔軟性が高い**が、内部は配列なので高速
- 要素数が不明だったり、追加・削除が多い時に使う

### 関係性
- **リストは配列を包んだ便利な道具**
- 配列の不便な点を関数で隠して、使いやすくしている
- 「配列の不便な部分を自動化したもの」と考えるとわかりやすい

---

## 🔧 List.cでの実例

### 配列だったら...
```c
// 素数を保存したいが、いくつ見つかるか分からない
double primes[1000000];  // 大きめに確保（無駄が多い）
int count = 0;
// 手動で管理する必要がある
```

### リストなら...
```c
List* primes = ListCreate();  // 最初は4個だけ
// 素数を見つけたら追加するだけ
if (IsPrime3(x, primes)) {
    ListAdd(primes, (double)x);  // 自動的に拡張される
}
// 簡単！
```

**これがリストの強み！** 🎉

