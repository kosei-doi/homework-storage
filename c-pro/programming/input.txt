1
Cプログラミング
第10回 リスト
電気・情報生命工学科クラス
早稲田大学 先進理工学部
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 1 / 20
動的メモリ確保 2
NULL値
#include <stdlib.h>
無効なポインタ値（アドレス値）を表す．
※殆どのシステムでNULL値はアドレス0であるが，これを前提としてはならない．
malloc関数/calloc関数/free関数
#include <stdlib.h>
void* malloc(size_t size); //sizeバイトのメモリを動的確保してポインタを返す
void* calloc(size_t n, size_t size); //sizeバイトのものをn個分確保してゼロクリア
void free(void* p); //動的確保メモリへのポインタを指定して解放
メモリの動的確保にはmalloc関数を，解放にはfree関数を用いる．メモリのヒープ領域が
使われる．size_t型はunsigned long型に同じ．void*はvoid型へのポインタ型．calloc関
数はmalloc関数に似る．n * sizeバイトを動的確保し，ゼロで初期化する．
※malloc/callocの戻り値がNULLの場合，メモリ不足によりメモリ確保に失敗したことを意味する．
※mallocはメモリ未初期化によるセキュリティリスクがあるため，callocを推奨．
※メモリ解放を忘れた場合，メモリが無駄に確保され続けることになり，メモリが逼迫する．プログラムが終了する
とOSが強制解放してくれるため，永続的にメモリを失う訳ではない．
※近年はガベージコレクション技術が発達し，実行途中で要不要を判定し，自動的にメモリ解放する言語が主流．
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 2 / 20
動的メモリ確保 3
配列を関数戻り値で返す際は，基本的に動的確保配列になる（自動確保配列は返せない）．
■ 自動確保配列はスコープを超えて存続させることはできない
double* NewDouble(size_t n) {
double A[n]; //Aのスコープはここからこの関数の終わりまでなので，
return A; //returnされるポインタはこの関数の呼び出し元では無効
}
■ 配列をスコープを超えて存続させたい場合は動的メモリ確保を行う
double* NewDouble(size_t n) {
double* p = calloc(n, sizeof(double)); //メモリ確保
return p;
}
■ 動的メモリ確保した場合，不要になったらメモリ解放を行う
double* p = NewDouble(n);
...
free(p); //メモリ解放
必要メモリサイズが大きい場合も動的確保配列を使用する．
※自動確保配列は最大でも1MiB程度しか確保できない．1KiBを超える場合は動的確保配列を推奨．
※他言語では静的配列を要素数が固定の配列，動的配列を要素数が自動的に拡張される配列と呼ぶ事があるので用語
に注意．
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 3 / 20
ユーティリティ 4
ユーティリティ関数/マクロ
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
// エラーメッセージを表示して強制終了
void Error(const char* message) {
fprintf(stdout, "\e[91m%s\e[m\n", message); // 通常はstderrを指定
exit(EXIT_FAILURE);
}
// エラーチェック付動的メモリ確保
void* Alloc(size_t size, int n) {
if (n < 0) Error("Alloc: size < 0");
void* p = calloc((size_t)n, size); // ゼロクリア付動的メモリ確保
if (p == NULL) Error("cannot allocate memory");
return p;
}
#define ALLOC1(type) Alloc(sizeof(type), 1) // 型付動的メモリ確保（単体）
#define ALLOCN(type, n) Alloc(sizeof(type), n) // 型付動的メモリ確保（配列）
■ エラーメッセージは通常stderrに出力するが，ここではstdoutとして同期させる
■ 動的メモリ確保は，ゴミの値を防ぐためゼロクリアする
■ 動的メモリ確保は，可読性向上のため型名を指定できるマクロにする
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 4 / 20
リスト 5
リスト
データ保持のための抽象的なデータ構造の一つ．同じ型の要素を複数記憶できる．
配列と同じく，通し番号（添字）により要素が配置される位置を指定する．
配列と異なり，予め要素数を決めておく必要はない．
■ 可能操作
● 参照：添字位置の要素を参照（読出し）
● 代入：添字位置に要素を代入（上書き）
● 削除：添字位置の要素を削除，以降の要素は前に詰める
● 挿入：添字位置に要素を挿入，以降の要素は後にずれる
● 追加：最後の位置に要素を追加
■ 実装方法
● アレイリスト（array list）
● 連結リスト（リンクリスト，linked list）
※本科目ではリストの通し番号も配列添字と同様，0始まりで数える
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 5 / 20
リスト 6
データ構造比較
■ 配列
● 最も高速に要素の参照/代入ができる．要素数は固定
■ アレイリスト
● 全要素を一つの配列に前詰めで管理
● 容量が不足した場合は自動的に余裕を持って拡張
■ 連結リスト
● ノード単位で管理．各ノードは要素1個と，次のノードへのポインタを保持
時間計算量比較
操作 配列 アレイリスト 連結リスト
参照/代入 O(1) O(1) O(𝑛)
追加 × O(1)† O(𝑛)
挿入 × O(𝑛) O(𝑛)
削除 × O(𝑛) O(𝑛)
†配列の拡張が必要になった場合はO(𝑛)
※アレイリストはメモリを追加・挿入操作に備えて余分に確保するが，連結リストは必要数のみ使用
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 6 / 20
アレイリスト-設計 7
構造体
// アレイリスト構造体
typedef struct {
double* Data; // 要素格納配列
int Size; // 要素格納配列のサイズ
int Count; // 要素格納個数
} List;
■ 要素の型がdouble型のアレイリストを作ることにする
■ 構造体を次のように定義し，これにより管理する
■ Dataにはdouble型の配列を要素数Sizeで動的確保する
■ Countには格納データ数を記録する
■ データは前詰めで記録する（配列内で添字番号0～Count-1番目に置く）
例：配列サイズ4，データ格納数3の場合
Data [0] [1] [2] [3]
Size=4
Count=3
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 7 / 20
アレイリスト-作成 8
Create関数
// アレイリストを作成
List* ListCreate(void) {
List* l = ALLOC1(List);
l->Count = 0;
l->Size = 4;
l->Data = ALLOCN(double, l->Size);
return l;
}
アレイリストを作成する
■1 アレイリスト構造体用のメモリを動的確保
■2 Countを0に，Sizeを4にする
■3 サイズがSizeの配列を動的確保し，Dataにセットする
■4 アレイリスト構造体へのポインタを返す
※初期サイズはメモリの浪費と再確保の手間のバランスをとって1～16程度の小さな数にする．ここでは4にする．
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 8 / 20
アレイリスト-廃棄 9
Dispose関数
// アレイリストを破棄
void ListDispose(List* l) {
free(l->Data);
free(l);
}
アレイリストを廃棄する
■1 Data配列を解放する
■2 アレイリスト構造体を解放する
※freeの順番を逆にしてはならない．l->Dataの値を記憶するメモリが別用途に使われて書き変わる可能性ある．
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 9 / 20
アレイリスト-要素参照/代入 10
GetItem関数/SetItem関数
// 指定位置の要素参照
double ListGetItem(List* l, int index) {
if (index < 0 || index >= l->Count) Error("ListGetItem: index OutOfRange");
return l->Data[index];
}
// 指定位置に要素代入
void ListSetItem(List* l, int index, double value) {
if (index < 0 || index >= l->Count) Error("ListSetItem: index OutOfRange");
l->Data[index] = value;
}
index番目の要素に参照/代入する
■1 indexが正当（0以上Count未満）かをチェック
■2 Data[index]を参照/代入する
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 10 / 20
アレイリスト-要素挿入 11
Insert関数
// 指定位置に要素挿入
void ListInsert(List* l, int index, double value) {
if (index < 0 || index > l->Count) Error("ListInsert: index OutOfRange");
if (l->Count < l->Size) { // 空き有り．後ろにずらす
for (int i = l->Count; --i >= index;) l->Data[i + 1] = l->Data[i];
} else { // 空き無し．メモリ再確保
double* old = l->Data; // 古い配列
l->Size *= 2; // 新しいサイズ
l->Data = ALLOCN(double, l->Size); // 新しい配列
for (int i = 0; i < index; i++) l->Data[i] = old[i];
for (int i = index; i < l->Count; i++) l->Data[i + 1] = old[i];
free(old); // 古い配列を解放
}
l->Data[index] = value; // 指定位置に代入
l->Count++; // 格納数を1増加
}
index番目の位置に新しい要素を割り込ませる
■1 indexの値が正当（0以上Count以下）かをチェック（Countの場合は追加になる）
■2 配列に空きの有る/無しに応じて処理が異なる（次頁）
■3 index番目に新しい要素を代入し，Countを1増加
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 11 / 20
アレイリストへ-要素挿入 12
■ 配列に空きが有る場合，要素を後ろから順にずらす
Size=8
Count=6→7
Data [0] [1] [2]
⃝4
[3]
⃝3
[4]
⃝2
[5]
⃝1
[6] [7]
⃝5
⋆ index=2に挿入したい
■ 配列に空きが無い場合，2倍のサイズの配列確保を行い，挿入位置より前の要素は同
じ位置へ，挿入位置より後の要素は一つ後の位置へコピーし，古い配列を解放
Size=4
Count=4
old
Data [0]
⃝1
[1]
⃝2
[2]
⃝3
[3]
⃝4
Size=8
Count=5
new
Data [0] [1] ⋆ [3] [4] [5] [6] [7]
⃝5
⋆ index=2に挿入したい
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 12 / 20
アレイリストへ-要素追加 13
Add関数
// 末尾に要素追加
void ListAdd(List* l, double value) {
ListInsert(l, l->Count, value);
}
アレイリストの末尾にデータを追加する
■1 Count番目の位置（空き領域の先頭）に新しいデータを挿入する
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 13 / 20
アレイリスト-要素削除 14
Remove関数
// 指定位置の要素削除
void ListRemove(List* l, int index) {
if (index < 0 || index >= l->Count) Error("ListRemove: index OutOfRange");
for (int i = index + 1; i < l->Count; i++) l->Data[i - 1] = l->Data[i];
l->Count--;
}
index番目の要素を削除する
■1 indexの値が正当（0以上Count未満）かをチェック
■2 index+1番目以降のデータを前から順に一つ前の位置にずらす
■3 Countを1減らす
■ 削除位置より後の要素を前から順に一つ前の位置に代入
Size=8
Count=6→5
Data [0] [1] [2] [3]
⃝1
[4]
⃝2
[5]
⃝3
[6] [7]
index=2を削除したい
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 14 / 20
素数判定法 15
ある自然数が素数か否かを判定する方法を素数判定法と呼ぶ．
素数定義
2以上の整数で，かつ，2以上かつその数未満の約数を一つも持たないもの．
※数学的に約数は整数でなければならない．
試行除算法[1]
// xが素数ならtrueを返す
bool IsPrime1(int x) {
if (x < 2) return false; // 2未満は非素数
for (int y = 2; y < x; y++) { // 2以上x未満について試行
if (x % y == 0) return false; // 割り切れたら非素数
}
return true; // 素数
}
整数𝑥が素数か否かを判定する．
■1 𝑥 < 2なら，非素数と判定して終了
■2 𝑦 ≔ 2, 3, 4, ..., 𝑥 − 1について，順に次を実行
● 𝑥 mod 𝑦 = 0であれば，非素数と判定して終了
■3 素数と判定して終了
※mod は剰余を表す．C言語では剰余演算子%を使う
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 15 / 20
素数判定法 16
試行除算法[2]
// xが素数ならtrueを返す
bool IsPrime2(int x) {
if (x < 2) return false; // 2未満は非素数
int w = (int)sqrt(x); // 試行上限を求める
for (int y = 2; y <= w; y++) { // 2以上w以下について試行
if (x % y == 0) return false; // 割り切れたら非素数
}
return true; // 素数
}
整数𝑥が素数か否かを判定する．
■1 𝑥 < 2なら，非素数と判定して終了
■2 𝑤 ≔ ⌊√𝑥⌋ を計算
■3 𝑦 ≔ 2, 3, 4, ..., 𝑤について，順に次を実行
● 𝑥 mod 𝑦 = 0であれば，非素数と判定して終了
■4 素数と判定して終了
※⌊𝑥⌋は床関数で，実数𝑥を超えない最大の整数を表す．𝑥が非負実数の場合は，型変換演算「(int)」のみでも可
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 16 / 20
素数判定法 17
試行除算法[3]
整数𝑥が素数か否かを判定する．
𝑥未満の素数𝑝0 < 𝑝1 < ... < 𝑝𝑐−1が全て分かっているものとする．
■1 𝑥 < 2なら，非素数と判定して終了
■2 𝑤 ≔ ⌊√𝑥⌋ を計算
■3 𝑖 ≔ 0, 1, ..., 𝑐 − 1について，順に次を実行
● 𝑦 ≔ 𝑝𝑖
● 𝑦 > 𝑤であれば，（これ以上調べる必要がないので）■4 へ
● 𝑥 mod 𝑦 = 0であれば，非素数と判定して終了
■4 素数と判定して終了
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 17 / 20
素数判定法 18
全要素が条件に合致
全要素がある条件に合致しているかを調べ
る．合致しない要素を発見したら終了．
ループを終えた時点で，全要素が合致して
いればbはtrue，そうでなければfalse．
bool b = true;
for (...) { // 各要素eについて
if (eが条件に合致しない) {
b = false;
break;
}
}
上記を関数として組む場合は，
for (...) { // 各要素eについて
if (eが条件に合致しない)
return false;
}
return true; // 全て合致した
ある要素が条件に合致
条件に合致する要素が一つでもあるかを調
べる．合致する要素を発見したら終了．
ループを終えた時点で，合致する要素があ
ればbはtrue，そうでなければfalse．
bool b = false;
for (...) { // 各要素eについて
if (eが条件に合致する) {
b = true;
break;
}
}
上記を関数として組む場合は，
for (...) { // 各要素eについて
if (eが条件に合致する)
return true;
}
return false; // 全て合致しなかった
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 18 / 20
演習課題 19
演習課題10（ファイル名: List.c）
アレイリストを実装する．また，試行除算法[3]を次の関数で実装する．
bool IsPrime3(int x, List* l);
但し，lはx未満の全素数が昇順に格納されているアレイリストへのポインタ．
n以下の素数の個数を数える次の関数を作って使う．
int CountPrimes3(int n);
■ Lv2 double型用のリストを実装する（要素参照時int型へ型変換必要）
■ Lv2 リストを作成して，素数を発見したら順に追加する
■ Lv2 100までの素数を表示させて，確認する
■ Lv2 𝑛 = 10000000の計算時間を試行除算法[2]と比較する
実行例（𝑛 = 100）：
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,
79, 83, 89, 97,
100以下の素数の個数: 25
実行例（𝑛 = 10000000）：
10000000以下の素数の個数: 664579
試行除算法[3]: 0.609938 [秒]
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 19 / 20
演習課題 20
演習課題解答例（一部分）
#include <time.h>
// func関数の処理時間を計測
double Measure(int n, int (*func)(int)) {
clock_t c0 = clock(); // 計測開始
int count = func(n); // n以下の素数を数える
clock_t c1 = clock(); // 計測終了
double span = (double)(c1 - c0) / (double)CLOCKS_PER_SEC; // 計算時間[秒]
printf("\n%d以下の素数の個数: %d\n", n, count);
return span;
}
int main(void) {
int n = 10000000;
printf("試行除算法[2]: %f [秒]\n", Measure(n, CountPrimes2));
printf("試行除算法[3]: %f [秒]\n", Measure(n, CountPrimes3));
return 0;
}
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第10回 リスト 20 / 20