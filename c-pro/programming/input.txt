1
Cプログラミング
第9回 ソート
電気・情報生命工学科クラス
早稲田大学 先進理工学部
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 1 / 18
ソート 2
ソート（整列，並べ替え，sorting）
配列の要素を順序関係に基づいて並べ替えること．
■ 順序関係
● 全ての2要素𝑥, 𝑦間について，どちらが先かを表したもの
◆ 等号・不等号記号を流用して，𝑥 < 𝑦，𝑥 = 𝑦，𝑥 > 𝑦と表現する．小さい方が先
◆ 𝑥 < 𝑦，𝑦 < 𝑧，𝑧 < 𝑥のように矛盾があってはならない
● 各要素を大小関係が明らかなもの（整数値や実数値）にマップしても良い
● 同順位の場合，ソート前の順序を保持する/しないものを安定ソート/不安定ソートと呼ぶ
● 文字列も，アルファベット順等の順序関係を定義すればソート可能（例: 辞書，名簿）
■ 時間計算量は要素数を𝑛とするとO(𝑛 log 𝑛)のものが標準的
■ 有名なアルゴリズム
● バブルソート（隣接交換法，O(𝑛2
)，安定ソート）
● 挿入ソート（単純挿入法，基本挿入法，O(𝑛2
)，安定ソート）
● 選択ソート（直接選択法，O(𝑛2
)）
● シェルソート（O(𝑛2
)～O(𝑛 log 𝑛)）
● マージソート（O(𝑛 log 𝑛)）
● ヒープソート（O(𝑛 log 𝑛)）
● クイックソート（O(𝑛 log 𝑛)）
● 基数ソート（O(𝑛)，安定ソート）
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 2 / 18
バブルソート 3
バブルソート（隣接交換法）
■ 隣接したデータの交換だけで実現される簡便なソート
■ 計算量O(𝑛2
)．安定ソート
※バブルソートは遅いため実用的でない．ここでは教育目的で扱う．
遅くとも簡便な安定ソートが必要な場合，ほぼ同等のアルゴリズムである挿入ソートを推奨．
バブルソートのアルゴリズム
要素数𝑛の配列𝑥0
, 𝑥1
, ..., 𝑥𝑛−1を昇順にソートする．
■1 ■2 の操作を，配列の先頭から要素数𝑚 = 𝑛, 𝑛−1, 𝑛−2, ..., 2について行い，終了
■2 𝑖 = 0, 1, ..., 𝑚−2について，
𝑥𝑗 > 𝑥𝑗+1ならば，𝑥𝑗と𝑥𝑗+1の値を交換する
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 3 / 18
バブルソート 4
要素数𝑛 = 5の昇順バブルソート例
■ 最初，要素数𝑚 = 5で並べ替え
● 0・1番目の比較入替
● 1・2番目の比較入替
● 2・3番目の比較入替
● 3・4番目の比較入替
結果，最大要素は最後に移動する
■ 次に，要素数𝑚 = 4で並べ替え
結果，2番目に大きい要素は最後から
2番目に移動する
■ 上記操作を𝑚 = 2まで繰り返す
上記操作を一般化したものが前頁のアル
ゴリズム
配列添字 [0] [1] [2] [3] [4]
5 3 1 4 2
3 5 1 4 2
3 1 5 4 2
3 1 4 5 2
3 1 4 2 ⃝5
1 3 4 2 ⃝5
1 3 4 2 ⃝5
1 3 2 ⃝4 ⃝5
1 3 2 ⃝4 ⃝5
1 2 ⃝3 ⃝4 ⃝5
1 ⃝2 ⃝3 ⃝4 ⃝5
要素数5で
並べ替え
要素数4で
並べ替え
要素数3で
並べ替え
要素数2で
並べ替え
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 4 / 18
バブルソート 5
練習1（ファイル名: Sort.c）
バブルソートのアルゴリズムに従って，double型配列に格納されているデータを昇順に並
べ替える次の関数を作成せよ．
void LetBubbleSort(int n, double data[n]);
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 5 / 18
バブルソート 6
実行例： 76 01 17 88 65 61 91 77 48 32 47 19 00 87 80 82 42 45 66 81
01 76 17 88 65 61 91 77 48 32 47 19 00 87 80 82 42 45 66 81
01 17 76 88 65 61 91 77 48 32 47 19 00 87 80 82 42 45 66 81
01 17 76 65 88 61 91 77 48 32 47 19 00 87 80 82 42 45 66 81
01 17 76 65 61 88 91 77 48 32 47 19 00 87 80 82 42 45 66 81
01 17 76 65 61 88 77 91 48 32 47 19 00 87 80 82 42 45 66 81
01 17 76 65 61 88 77 48 91 32 47 19 00 87 80 82 42 45 66 81
01 17 76 65 61 88 77 48 32 91 47 19 00 87 80 82 42 45 66 81
01 17 76 65 61 88 77 48 32 47 91 19 00 87 80 82 42 45 66 81
01 17 76 65 61 88 77 48 32 47 19 91 00 87 80 82 42 45 66 81
01 17 76 65 61 88 77 48 32 47 19 00 91 87 80 82 42 45 66 81
01 17 76 65 61 88 77 48 32 47 19 00 87 91 80 82 42 45 66 81
01 17 76 65 61 88 77 48 32 47 19 00 87 80 91 82 42 45 66 81
01 17 76 65 61 88 77 48 32 47 19 00 87 80 82 91 42 45 66 81
01 17 76 65 61 88 77 48 32 47 19 00 87 80 82 42 91 45 66 81
01 17 76 65 61 88 77 48 32 47 19 00 87 80 82 42 45 91 66 81
01 17 76 65 61 88 77 48 32 47 19 00 87 80 82 42 45 66 91 81
01 17 76 65 61 88 77 48 32 47 19 00 87 80 82 42 45 66 81 91
01 17 65 76 61 88 77 48 32 47 19 00 87 80 82 42 45 66 81 |
01 17 65 61 76 88 77 48 32 47 19 00 87 80 82 42 45 66 81 |
01 17 65 61 76 77 88 48 32 47 19 00 87 80 82 42 45 66 81 |
01 17 65 61 76 77 48 88 32 47 19 00 87 80 82 42 45 66 81 |
01 17 65 61 76 77 48 32 88 47 19 00 87 80 82 42 45 66 81 |
01 17 65 61 76 77 48 32 47 88 19 00 87 80 82 42 45 66 81 |
01 17 65 61 76 77 48 32 47 19 88 00 87 80 82 42 45 66 81 |
01 17 65 61 76 77 48 32 47 19 00 88 87 80 82 42 45 66 81 |
01 17 65 61 76 77 48 32 47 19 00 87 88 80 82 42 45 66 81 |
01 17 65 61 76 77 48 32 47 19 00 87 80 88 82 42 45 66 81 |
01 17 65 61 76 77 48 32 47 19 00 87 80 82 88 42 45 66 81 |
01 17 65 61 76 77 48 32 47 19 00 87 80 82 42 88 45 66 81 |
01 17 65 61 76 77 48 32 47 19 00 87 80 82 42 45 88 66 81 |
01 17 65 61 76 77 48 32 47 19 00 87 80 82 42 45 66 88 81 |
01 17 65 61 76 77 48 32 47 19 00 87 80 82 42 45 66 81 88 |
01 17 61 65 76 77 48 32 47 19 00 87 80 82 42 45 66 81 | |
01 17 61 65 76 48 77 32 47 19 00 87 80 82 42 45 66 81 | |
01 17 61 65 76 48 32 77 47 19 00 87 80 82 42 45 66 81 | |
01 17 61 65 76 48 32 47 77 19 00 87 80 82 42 45 66 81 | |
01 17 61 65 76 48 32 47 19 77 00 87 80 82 42 45 66 81 | |
01 17 61 65 76 48 32 47 19 00 77 87 80 82 42 45 66 81 | |
01 17 61 65 76 48 32 47 19 00 77 80 87 82 42 45 66 81 | |
01 17 61 65 76 48 32 47 19 00 77 80 82 87 42 45 66 81 | |
01 17 61 65 76 48 32 47 19 00 77 80 82 42 87 45 66 81 | |
01 17 61 65 76 48 32 47 19 00 77 80 82 42 45 87 66 81 | |
01 17 61 65 76 48 32 47 19 00 77 80 82 42 45 66 87 81 | |
01 17 61 65 76 48 32 47 19 00 77 80 82 42 45 66 81 87 | |
01 17 61 65 48 76 32 47 19 00 77 80 82 42 45 66 81 | | |
01 17 61 65 48 32 76 47 19 00 77 80 82 42 45 66 81 | | |
01 17 61 65 48 32 47 76 19 00 77 80 82 42 45 66 81 | | |
01 17 61 65 48 32 47 19 76 00 77 80 82 42 45 66 81 | | |
01 17 61 65 48 32 47 19 00 76 77 80 82 42 45 66 81 | | |
01 17 61 65 48 32 47 19 00 76 77 80 42 82 45 66 81 | | |
01 17 61 65 48 32 47 19 00 76 77 80 42 45 82 66 81 | | |
01 17 61 65 48 32 47 19 00 76 77 80 42 45 66 82 81 | | |
01 17 61 65 48 32 47 19 00 76 77 80 42 45 66 81 82 | | |
01 17 61 48 65 32 47 19 00 76 77 80 42 45 66 81 | | | |
01 17 61 48 32 65 47 19 00 76 77 80 42 45 66 81 | | | |
01 17 61 48 32 47 65 19 00 76 77 80 42 45 66 81 | | | |
01 17 61 48 32 47 19 65 00 76 77 80 42 45 66 81 | | | |
01 17 61 48 32 47 19 00 65 76 77 80 42 45 66 81 | | | |
01 17 61 48 32 47 19 00 65 76 77 42 80 45 66 81 | | | |
01 17 61 48 32 47 19 00 65 76 77 42 45 80 66 81 | | | |
01 17 61 48 32 47 19 00 65 76 77 42 45 66 80 81 | | | |
01 17 48 61 32 47 19 00 65 76 77 42 45 66 80 | | | | |
01 17 48 32 61 47 19 00 65 76 77 42 45 66 80 | | | | |
01 17 48 32 47 61 19 00 65 76 77 42 45 66 80 | | | | |
01 17 48 32 47 19 61 00 65 76 77 42 45 66 80 | | | | |
01 17 48 32 47 19 00 61 65 76 77 42 45 66 80 | | | | |
01 17 48 32 47 19 00 61 65 76 42 77 45 66 80 | | | | |
01 17 48 32 47 19 00 61 65 76 42 45 77 66 80 | | | | |
01 17 48 32 47 19 00 61 65 76 42 45 66 77 80 | | | | |
01 17 32 48 47 19 00 61 65 76 42 45 66 77 | | | | | |
01 17 32 47 48 19 00 61 65 76 42 45 66 77 | | | | | |
01 17 32 47 19 48 00 61 65 76 42 45 66 77 | | | | | |
01 17 32 47 19 00 48 61 65 76 42 45 66 77 | | | | | |
01 17 32 47 19 00 48 61 65 42 76 45 66 77 | | | | | |
01 17 32 47 19 00 48 61 65 42 45 76 66 77 | | | | | |
01 17 32 47 19 00 48 61 65 42 45 66 76 77 | | | | | |
01 17 32 19 47 00 48 61 65 42 45 66 76 | | | | | | |
01 17 32 19 00 47 48 61 65 42 45 66 76 | | | | | | |
01 17 32 19 00 47 48 61 42 65 45 66 76 | | | | | | |
01 17 32 19 00 47 48 61 42 45 65 66 76 | | | | | | |
01 17 19 32 00 47 48 61 42 45 65 66 | | | | | | | |
01 17 19 00 32 47 48 61 42 45 65 66 | | | | | | | |
01 17 19 00 32 47 48 42 61 45 65 66 | | | | | | | |
01 17 19 00 32 47 48 42 45 61 65 66 | | | | | | | |
01 17 00 19 32 47 48 42 45 61 65 | | | | | | | | |
01 17 00 19 32 47 42 48 45 61 65 | | | | | | | | |
01 17 00 19 32 47 42 45 48 61 65 | | | | | | | | |
01 00 17 19 32 47 42 45 48 61 | | | | | | | | | |
01 00 17 19 32 42 47 45 48 61 | | | | | | | | | |
01 00 17 19 32 42 45 47 48 61 | | | | | | | | | |
00 01 17 19 32 42 45 47 48 | | | | | | | | | | |
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 6 / 18
バブルソート 7
練習1解答例
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
// データを表示
void PrintData(int n, double data[n], int L, int R) {
for (int i = 0; i < n; i++) {
if (L <= i && i <= R)
printf("%02.0f ", data[i]); // L～R番要素表示
else
printf(" | "); // それ以外は縦線を表示
}
printf("\n");
}
// データ生成
void SetData(int n, double data[n]) {
srandom(1127);
for (int i = 0; i < n; i++)
data[i] = (int)random() % 100; // 0～99の整数乱数
}
int main(void) {
int n = 20;
double data[n];
SetData(n, data);
LetBubbleSort(n, data);
return 0;
}
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 7 / 18
バブルソート 8
練習1解答例
// Swap関数
void Swap(double* x, double* y) {
double a = *x;
double b = *y;
*y = a;
*x = b;
}
// dataの要素を昇順にバブルソート
void LetBubbleSort(int n, double data[n]) {
PrintData(n, data, 0, n - 1); // デバッグ用表示
for (int m = n; m >= 2; m--) { // 残り要素数ループ
for (int i = 0; i < m - 1; i++) { // 添字ループ
if (data[i] <= data[i + 1]) continue; // 大小関係OK
Swap(&data[i], &data[i + 1]); // 入替
PrintData(n, data, 0, m - 1); // デバッグ用表示
}
}
}
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 8 / 18
クイックソート 9
クイックソート
■ 高速とされる標準的な並べ替えアルゴリズム
■ 不安定ソート
■ 計算量は平均的にはO(𝑛 log 𝑛)，最悪の場合はO(𝑛2
)
● 一般的に大規模データに使用して問題ないが，拘る場合は他手法も考慮する
■ アルゴリズム概要
● 配列の真ん中の要素をピボットに選ぶ
● ピボットより先か後かで，全要素を前半・後半に並べ替える（ピボット自身も移動する）
● 以上の操作を，前半部分，後半部分，それぞれに対して再帰的に繰り返す
■ 補足
● ピボットは中央値に近いと半々に分けられて高効率
● ピボットと同順位の要素は，前半・後半どちらに並べ替えても可
（実は，どちらにも属さない，前半後半の間でも可）
※クイックソートをソート済みのデータに適用すると（何もする必要が無いにも関わらず）最悪の計算量（O(𝑛2)）
がかかると文献によっては説明される．これは，ピボットに最初又は最後のデータを選んだ場合であり，上記のよ
うに真ん中のデータを選ぶ場合は，このようなことにはならない．
※再帰が深くなった場合（2 log 𝑛など）にヒープソートに移行するイントロソートという手法もある．
ヒープソートは平均的にはクイックソートより遅いが，最悪計算量もO(𝑛 log 𝑛)である．
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 9 / 18
クイックソート 10
クイックソートのアルゴリズム
配列内の連続する要素𝑥𝐿, 𝑥𝐿+1, ..., 𝑥𝑅を昇順にソートする
■1 𝑙 ← 𝐿，𝑟 ← 𝑅，ピボットの値𝑝 ← 𝑥⌊(𝐿+𝑅)/2⌋
■2 𝑟 < 𝑙なら■8 へ
■3 𝑥𝑙 < 𝑝である限り，𝑙 ← 𝑙 + 1を繰り返す
■4 𝑝 < 𝑥𝑟である限り，𝑟 ← 𝑟 − 1を繰り返す
■5 𝑟 < 𝑙なら■8 へ
■6 𝑙 < 𝑟なら𝑥𝑙と𝑥𝑟の値を入れ替え
■7 𝑙 ← 𝑙 + 1，𝑟 ← 𝑟 − 1として，■2 へ
■8 𝐿 < 𝑟ならば，𝑥𝐿, 𝑥𝐿+1, ..., 𝑥𝑟のデータについて本アルゴリズムを再適用
■9 𝑙 < 𝑅ならば，𝑥𝑙
, 𝑥𝑙+1, ..., 𝑥𝑅のデータについて本アルゴリズムを再適用
■ ■8 , ■9 の条件は，残り要素数2以上を意味する
■ 要素数𝑛の配列𝑥0
, 𝑥1
, ..., 𝑥𝑛−1全体をソートするには，𝐿 ← 0，𝑅 ← 𝑛−1として上記アル
ゴリズムを適用
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 10 / 18
クイックソート 11
■ lは左端からピボット以上の値を探して停止（•）
rは右端からピボット以下の値を探して停止（•）
■ 停止位置がl<rであればデータを入れ替え
■ l ← l+1
r ← r-1
■ r<lなら終了
前半部分/後半部分にデータが2個以上あれば再帰的
に上記操作を行う
10 30 40 30 50 50 20 40
l r
L=0 R=7 pivot
10 20 40 30 50 50 30 40
l r
10 20 30 40 50 50 30 40
r l
10 20 30
l r
L=0 R=2 pivot
10 20 30
r l
40 50 50 30 40
l r
L=3 R=7 pivot
40 40 50 30 50
l r
40 40 30 50 50
r l
40 40 30
l r
L=3 R=5 pivot
30 40 40
l r
30 40 40
r l
50 50
l r
L=6 R=7 pivot
50 50
r l
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 11 / 18
クイックソート 12
練習2
クイックソートのアルゴリズムに従って，double型配列に格納されている要素を昇順に並
べ替える関数を練習1と同様に作成せよ．
■ 再起関数の部分は，
void LetQuickSort_(int n, double data[n], int L, int R);
として作成する．
■ 配列全体をソートする関数は，
void LetQuickSort(int n, double data[n]);
で行い，この中でLetQuickSort_関数を呼び出して使う．
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 12 / 18
クイックソート 13
実行例：
76 01 17 88 65 61 91 77 48 32 47 19 00 87 80 82 42 45 66 81
00 01 17 88 65 61 91 77 48 32 47 19 76 87 80 82 42 45 66 81
00 01 17 19 65 61 91 77 48 32 47 88 76 87 80 82 42 45 66 81
00 01 17 19 32 61 91 77 48 65 47 88 76 87 80 82 42 45 66 81
00 01 17 19 32 | | | | | | | | | | | | | | |
00 01 | | | | | | | | | | | | | | | | | |
| | | 19 32 | | | | | | | | | | | | | | |
| | | | | 61 66 77 48 65 47 88 76 87 80 82 42 45 91 81
| | | | | 61 66 45 48 65 47 88 76 87 80 82 42 77 91 81
| | | | | 61 66 45 48 65 47 42 76 87 80 82 88 77 91 81
| | | | | 61 66 45 48 65 47 42 76 87 80 82 88 77 91 81
| | | | | 42 66 45 48 65 47 61 | | | | | | | |
| | | | | 42 47 45 48 65 66 61 | | | | | | | |
| | | | | 42 47 45 48 65 66 61 | | | | | | | |
| | | | | 42 45 47 | | | | | | | | | | | |
| | | | | 42 45 | | | | | | | | | | | | |
| | | | | | | | | 65 61 66 | | | | | | | |
| | | | | | | | | 61 65 | | | | | | | | |
| | | | | | | | | | | | | 87 80 82 81 77 91 88
| | | | | | | | | | | | | 77 80 82 81 87 | |
| | | | | | | | | | | | | 77 80 81 82 87 | |
| | | | | | | | | | | | | 77 80 81 | | | |
| | | | | | | | | | | | | | | | 82 87 | |
| | | | | | | | | | | | | | | | | | 88 91
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 13 / 18
クイックソート 14
練習2解答例
void LetQuickSort_(int n, double data[n], int L, int R) {
int l = L; // step 1
int r = R;
double pivot = data[(L + R) / 2];
while (true) { // step 2-7 のループ
if (r < l) break; // step 2
while (data[l] < pivot) l++; // step 3
while (pivot < data[r]) r--; // step 4
if (r < l) break; // step 5
if (l < r) Swap(&data[l], &data[r]); // step 6
l++; // step 7
r--;
PrintData(n, data, L, R); // デバッグ用表示
}
if (L < r) LetQuickSort_(n, data, L, r); // step 8
if (l < R) LetQuickSort_(n, data, l, R); // step 9
}
// dataの要素を昇順にクイックソート
void LetQuickSort(int n, double data[n]) {
PrintData(n, data, 0, n - 1); // デバッグ用表示
if (n >= 2) LetQuickSort_(n, data, 0, n - 1);
}
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 14 / 18
クイックソート 15
練習3
配列の要素数𝑛を3, 30, 300, 3000, 30000にして，バブルソートとクイックソートの処理時間
を比較せよ．
■ 途中経過表示に時間がかかるので，PrintData関数の冒頭にreturn; を挿入して表示を
無効化する
実行例（要素数が大きければクイックソートの方が高速）
n BubbleSort [秒] QuickSort [秒]
3 0.000000 0.000000
30 0.000000 0.000000
300 0.000000 0.000000
3000 0.005504 0.000000
30000 1.319878 0.002001
clock関数
#include <time.h>
clock_t clock(void);
プログラムの使用したプロセッサ時間の近似値を返す．
単位を秒に変換するには，定数CLOCKS_PER_SECで割る．
※clock_tはlong int型．
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 15 / 18
クイックソート 16
練習3解答例
#include <time.h>
...
// sort関数の処理時間を計測
double Measure(int n, void (*sort)(int, double[])) {
double data[n];
SetData(n, data);
clock_t c0 = clock(); // 計測開始
sort(n, data); // ソート関数呼出
clock_t c1 = clock(); // 計測終了
return (double)(c1 - c0) / (double)CLOCKS_PER_SEC; // 計算時間[秒]
}
int main(void) {
printf("n\tBubbleSort [秒]\tQuickSort [秒]\n");
for (int n = 3; n <= 30000; n *= 10) {
printf("%d\t%f\t%f\n", n, //
Measure(n, LetBubbleSort), //
Measure(n, LetQuickSort));
}
return 0;
}
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 16 / 18
分位数 17
分位数（分位点，quantile）
昇順に並べ替えられた実数列𝑥0
, 𝑥1
, ..., 𝑥𝑛−1について，次の数を𝑞分位数と定義する．
𝑄𝑞 ≔
⎧
{
⎨
{
⎩
𝑥𝑡
(𝑟 = 0)
(1 − 𝑟) 𝑥𝑡 + 𝑟 𝑥𝑡+1 (𝑟 ≠ 0)
但し𝑛 ≥ 2，𝑞 ∈ [0, 1]，
𝑠 ≔ (𝑛 − 1)𝑞
𝑡 ≔ ⌊𝑠⌋
𝑟 ≔ 𝑠 − 𝑡
■ 𝑄0 = 𝑥0，𝑄1 = 𝑥𝑛−1である
■ 𝑄1/2を中央値（median）と呼ぶ
■ 𝑄1/4を第1四分位数，𝑄3/4を第3四分位数と呼ぶ
※数学では，数列の序数は1始まりにするので，𝑠の定義に1を加える．𝑡も1大きいものになる
※分位数の定義は様々在る．文部科学省が学習指導要領の解説で示す四分位数の定義は上記と異なるので注意
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 17 / 18
演習課題 18
演習課題09
■ Lv2 昇順に並べ替えられたデータを基に𝑞分位数を計算する次の関数を作る
double Quantile(int n, double data[n], double q);
■ Lv2 練習2のデータの最小値，第1四分位数，中央値，第3四分位数，最大値を表示する
実行例：
0/4-quantile: 0.000000
1/4-quantile: 39.500000
2/4-quantile: 63.000000
3/4-quantile: 80.250000
4/4-quantile: 91.000000
早稲田大学 先進理工学部 電気・情報生命工学科クラス Cプログラミング 第9回 ソート 18 / 18