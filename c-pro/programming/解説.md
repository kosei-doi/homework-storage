# List.c コード解説

## 📚 全体の概要

このプログラムは以下の2つの主要な機能を持っています：
1. **アレイリスト（ArrayList）**：動的にサイズが変わる配列のようなデータ構造
2. **素数判定プログラム**：効率的な方法で素数を見つける

---

## 🔧 第1部：ユーティリティ関数（便利な道具）

### 1. `Error`関数
```c
void Error(const char* message) {
    fprintf(stdout, "\e[91m%s\e[m\n", message);
    exit(EXIT_FAILURE);
}
```
**役割**：エラーメッセージを赤色で表示してプログラムを強制終了する

**例**：メモリが足りない時などに「cannot allocate memory」と表示して終了

---

### 2. `Alloc`関数
```c
void* Alloc(size_t size, int n) {
    if (n < 0) Error("Alloc: size < 0");
    void* p = calloc((size_t)n, size);
    if (p == NULL) Error("cannot allocate memory");
    return p;
}
```
**役割**：安全にメモリを確保する（エラーチェック付き）

**仕組み**：
- `calloc`でメモリを確保（自動的に0で初期化される）
- 失敗したらエラー表示して終了
- 成功したら確保したメモリのアドレスを返す

**例**：`Alloc(sizeof(double), 10)` → double型10個分（80バイト）のメモリを確保

---

### 3. マクロ定義
```c
#define ALLOC1(type) Alloc(sizeof(type), 1)
#define ALLOCN(type, n) Alloc(sizeof(type), n)
```
**役割**：メモリ確保を簡単にする

**使い方**：
- `ALLOC1(List)` → List型1個分のメモリを確保
- `ALLOCN(double, 100)` → double型100個分のメモリを確保

---

## 📦 第2部：アレイリスト（動的配列）

### データ構造
```c
typedef struct {
    double* Data;    // 実際にデータを保存する配列
    int Size;        // 配列の容量（確保したメモリの大きさ）
    int Count;       // 実際に入っているデータの個数
} List;
```

**イメージ**：
```
Size = 8 (箱が8個ある)
Count = 5 (実際にデータが5個入っている)

Data: [2.0] [3.0] [5.0] [7.0] [11.0] [空] [空] [空]
       0      1     2     3      4     5    6    7
```

---

### 1. `ListCreate`関数：リストを作成
```c
List* ListCreate(void) {
    List* l = ALLOC1(List);
    l->Count = 0;      // 最初は何も入っていない
    l->Size = 4;       // 最初は4個分の容量
    l->Data = ALLOCN(double, l->Size);  // 4個分のメモリを確保
    return l;
}
```
**役割**：空のリストを新しく作る

**動作**：
1. List構造体用のメモリを確保
2. データ数0、容量4の初期状態にする
3. double型4個分の配列を確保

---

### 2. `ListDispose`関数：リストを削除
```c
void ListDispose(List* l) {
    free(l->Data);  // まず配列のメモリを解放
    free(l);        // 次に構造体のメモリを解放
}
```
**役割**：使わなくなったリストのメモリを解放する

**注意**：順番が大切！先にDataを解放してから構造体を解放

---

### 3. `ListGetItem`関数：要素を取得
```c
double ListGetItem(List* l, int index) {
    if (index < 0 || index >= l->Count) Error("ListGetItem: index OutOfRange");
    return l->Data[index];
}
```
**役割**：指定した位置のデータを取り出す

**例**：`ListGetItem(l, 2)` → リストの2番目の要素を返す

**チェック**：範囲外アクセスを防ぐ

---

### 4. `ListSetItem`関数：要素を設定
```c
void ListSetItem(List* l, int index, double value) {
    if (index < 0 || index >= l->Count) Error("ListSetItem: index OutOfRange");
    l->Data[index] = value;
}
```
**役割**：指定した位置のデータを変更する

**例**：`ListSetItem(l, 1, 99.0)` → リストの1番目を99.0に変更

---

### 5. `ListInsert`関数：要素を挿入（重要！）
```c
void ListInsert(List* l, int index, double value) {
    // 1. 範囲チェック
    if (index < 0 || index > l->Count) Error("ListInsert: index OutOfRange");
    
    // 2. 空きがあるかチェック
    if (l->Count < l->Size) {
        // 空きがある場合：後ろにずらす
        for (int i = l->Count; --i >= index;) 
            l->Data[i + 1] = l->Data[i];
    } else {
        // 空きがない場合：メモリを2倍に拡張
        double* old = l->Data;
        l->Size *= 2;
        l->Data = ALLOCN(double, l->Size);
        // 古いデータを新しい配列にコピー
        for (int i = 0; i < index; i++) 
            l->Data[i] = old[i];
        for (int i = index; i < l->Count; i++) 
            l->Data[i + 1] = old[i];
        free(old);
    }
    // 3. 新しい値を入れて、データ数を増やす
    l->Data[index] = value;
    l->Count++;
}
```

**役割**：指定した位置に新しい要素を挿入する

**2つのパターン**：

#### パターン1：空きがある場合
```
元の状態：
Data: [2] [3] [5] [7] [空] [空] [空] [空]
       0   1   2   3    4    5    6    7
Count = 4, Size = 8

index=2に11を挿入：
1. 2番目以降を後ろにずらす
   [2] [3] [空] [5] [7] [空] [空] [空]
2. 2番目に11を入れる
   [2] [3] [11] [5] [7] [空] [空] [空]
Count = 5
```

#### パターン2：空きがない場合
```
元の状態：
Data: [2] [3] [5] [7]
       0   1   2   3
Count = 4, Size = 4

1. サイズを2倍に（Size = 8）
2. 新しい配列を作る
3. 古いデータをコピー
4. 挿入位置で分けてコピー
5. 新しい値を入れる
```

---

### 6. `ListAdd`関数：末尾に追加
```c
void ListAdd(List* l, double value) {
    ListInsert(l, l->Count, value);
}
```
**役割**：リストの最後に要素を追加する

**仕組み**：`ListInsert`を最後の位置（Count番目）で呼び出すだけ

**例**：`ListAdd(l, 13.0)` → リストの最後に13.0を追加

---

### 7. `ListRemove`関数：要素を削除
```c
void ListRemove(List* l, int index) {
    if (index < 0 || index >= l->Count) Error("ListRemove: index OutOfRange");
    // 後ろの要素を前にずらす
    for (int i = index + 1; i < l->Count; i++) 
        l->Data[i - 1] = l->Data[i];
    l->Count--;
}
```
**役割**：指定した位置の要素を削除する

**動作**：
```
元の状態：
Data: [2] [3] [5] [7] [11]
       0   1   2   3    4
Count = 5

index=2（5を削除）を削除：
1. 3番目以降を前にずらす
   [2] [3] [7] [11] [11]
2. Countを減らす
   [2] [3] [7] [11] [空]
Count = 4
```

---

## 🔢 第3部：素数判定アルゴリズム

### 素数とは？
2以上の整数で、1と自分自身以外で割り切れない数

**例**：2, 3, 5, 7, 11, 13, 17, 19, ...

---

### 方法1：`IsPrime2`（試行除算法[2]）
```c
bool IsPrime2(int x) {
    if (x < 2) return false;           // 2未満は素数ではない
    int w = (int)sqrt(x);              // √x まで調べれば十分
    for (int y = 2; y <= w; y++) {
        if (x % y == 0) return false;  // 割り切れたら素数ではない
    }
    return true;                        // 割り切れなければ素数
}
```

**仕組み**：
- 2から√xまで順番に割り算してみる
- 1つでも割り切れたら素数ではない
- 全部割り切れなかったら素数

**なぜ√xまで？**
もしxがa×bと分解できるなら、小さい方は√x以下になるから

**例**：17が素数か？
- √17 ≈ 4.12
- 2で割り切れる？ → いいえ（17 ÷ 2 = 8余り1）
- 3で割り切れる？ → いいえ（17 ÷ 3 = 5余り2）
- 4で割り切れる？ → いいえ（17 ÷ 4 = 4余り1）
- → 素数！

---

### 方法2：`IsPrime3`（試行除算法[3] - より効率的）
```c
bool IsPrime3(int x, List* l) {
    if (x < 2) return false;
    int w = (int)sqrt(x);
    // リストに保存された素数だけで割り算
    for (int i = 0; i < l->Count; i++) {
        int y = (int)ListGetItem(l, i);
        if (y > w) break;              // √xを超えたら終了
        if (x % y == 0) return false;
    }
    return true;
}
```

**仕組み**：
- 既に見つけた素数だけを使って判定
- 合成数（素数ではない数）で割る必要はない

**なぜ速い？**
- 普通の方法：2, 3, 4, 5, 6, 7, 8, 9, 10... で割る
- この方法：2, 3, 5, 7（素数だけ）で割る
- 4, 6, 8, 9, 10などは既に2や3で判定済みなので不要

**例**：19が素数か？（既に2, 3, 5, 7, 11, 13, 17がリストにある）
- √19 ≈ 4.36
- 2で割り切れる？ → いいえ
- 3で割り切れる？ → いいえ
- 5は4.36より大きいので終了
- → 素数！

---

### `CountPrimes2`関数：素数を数える（方法1）
```c
int CountPrimes2(int n) {
    int count = 0;
    for (int x = 2; x <= n; x++) {
        if (IsPrime2(x)) count++;
    }
    return count;
}
```
**役割**：2からnまで、全ての数について`IsPrime2`で判定して数える

---

### `CountPrimes3`関数：素数を数える（方法2 - より効率的）
```c
int CountPrimes3(int n) {
    List* l = ListCreate();  // 素数を保存するリスト
    int count = 0;
    for (int x = 2; x <= n; x++) {
        if (IsPrime3(x, l)) {      // 素数か判定
            ListAdd(l, (double)x); // 素数ならリストに追加
            count++;
        }
    }
    ListDispose(l);
    return count;
}
```
**役割**：2からnまで、`IsPrime3`で判定しながら、見つけた素数をリストに保存

**ポイント**：
- 素数を見つけたらリストに追加
- 次の数を判定する時に、そのリストを使う
- これによりどんどん速くなる

---

### `Measure`関数：処理時間を測定
```c
double Measure(int n, int (*func)(int)) {
    clock_t c0 = clock();           // 開始時刻
    int count = func(n);            // 関数を実行
    clock_t c1 = clock();           // 終了時刻
    double span = (double)(c1 - c0) / (double)CLOCKS_PER_SEC;
    printf("\n%d以下の素数の個数: %d\n", n, count);
    return span;
}
```
**役割**：関数の実行時間を測定する

**仕組み**：
- `clock()`で開始時刻と終了時刻を取得
- 差を秒に変換
- 結果を表示して時間を返す

---

## 🎯 第4部：メイン関数

```c
int main(void) {
    // パート1：100までの素数を表示
    List* l = ListCreate();
    int first = 1;
    for (int x = 2; x <= 100; x++) {
        if (IsPrime3(x, l)) {
            if (!first) printf(", ");  // 最初以外はカンマを表示
            printf("%d", x);
            ListAdd(l, (double)x);
            first = 0;
        }
    }
    printf(",\n");
    printf("100以下の素数の個数: %d\n", l->Count);
    ListDispose(l);

    // パート2：10000000までの素数を数えて時間測定
    int n = 10000000;
    printf("試行除算法[2]: %f [秒]\n", Measure(n, CountPrimes2));
    printf("試行除算法[3]: %f [秒]\n", Measure(n, CountPrimes3));
    return 0;
}
```

**動作**：

1. **100までの素数表示**
   - 2から100まで順番に調べる
   - 素数を見つけたら表示してリストに追加
   - 最後に個数を表示

2. **計算時間の比較**
   - 10000000までの素数を2つの方法で数える
   - それぞれの実行時間を表示
   - 方法3の方が速いはず

---

## 💡 ポイントまとめ

### アレイリストの特徴
- ✅ 動的にサイズが変わる（自動的に拡張される）
- ✅ 挿入・削除ができる（普通の配列にはできない）
- ✅ 要素へのアクセスが高速

### 素数判定の最適化
- ✅ 方法2：√xまで調べる
- ✅ 方法3：既知の素数だけを使う
- ✅ 方法3の方が圧倒的に速い（特に大きな数で）

### メモリ管理
- ✅ 動的メモリ確保（calloc）
- ✅ 使用後は必ず解放（free）
- ✅ エラーチェック付き

---

## 🚀 実行例

```
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,
79, 83, 89, 97,
100以下の素数の個数: 25

10000000以下の素数の個数: 664579
試行除算法[2]: 2.345678 [秒]

10000000以下の素数の個数: 664579
試行除算法[3]: 0.609938 [秒]
```

方法3の方が約4倍速い！

